{
  "version": 3,
  "sources": ["../../../src/optimizer/transforms/extract-suffix.ts"],
  "sourcesContent": ["import type {Visitor} from '../../traverser/traverse.js';\nimport {isAlternativeContainer} from '../../parser/node-utils.js';\nimport {createAlternative, createGroup} from '../../parser/parse.js';\nimport {isAllowedSimpleType, isNodeEqual} from './extract-prefix.js';\n\n/**\nExtract nodes at the end of every alternative into a suffix.\nEx: `aa$|bba$|ca$` -> `(?:a|bb|c)a$`.\nAlso works within groups.\n*/\nconst extractSuffix: Visitor = {\n  '*'({node}) {\n    if (!isAlternativeContainer(node) || node.body.length < 2) {\n      return;\n    }\n    const firstAltEls = node.body[0].body;\n    const suffixNodes = [];\n    let passedSharedSuffix = false;\n    let i = 0;\n    while (!passedSharedSuffix) {\n      const inverseI = firstAltEls.length - 1 - i;\n      suffixNodes.push(firstAltEls[inverseI]);\n      for (const alt of node.body) {\n        const inverseIOfAlt = alt.body.length - 1 - i;\n        const kid = alt.body[inverseIOfAlt];\n        if (!kid || !isAllowedSimpleType(kid.type) || !isNodeEqual(kid, suffixNodes[i])) {\n          passedSharedSuffix = true;\n          break;\n        }\n      }\n      i++;\n    }\n    suffixNodes.pop();\n    if (\n      !suffixNodes.length ||\n      // Avoid applying in cases when it would lengthen the pattern without any benefit; ex:\n      // `true|false` -> `(?:tru|fals)e`\n      ( suffixNodes.length === 1 &&\n        // Extract a single-node suffix if it's an assertion, since that provides a readability\n        // benefit and is more likely to trigger follow-on optimizations\n        suffixNodes[0].type !== 'Assertion' &&\n        // Four chars are added by the `(?:)` wrapper, so avoid applying if could be net negative\n        node.body.length < 4 &&\n        // Alts reduced to 0 or 1 node after extracting the suffix can possibly be collapsed in\n        // follow-on optimizations, providing a performance and/or minification benefit\n        node.body.every(alt => alt.body.length > 2)\n      )\n    ) {\n      return;\n    }\n    suffixNodes.reverse();\n\n    for (const alt of node.body) {\n      alt.body = alt.body.slice(0, -suffixNodes.length);\n    }\n    const newContentsAlt = createAlternative();\n    const prefixGroup = createGroup({body: node.body});\n    if (!prefixGroup.body.every(alt => !alt.body.length)) {\n      newContentsAlt.body.push(prefixGroup);\n    }\n    newContentsAlt.body.push(...suffixNodes);\n    node.body = [newContentsAlt];\n  },\n};\n\nexport {\n  extractSuffix,\n};\n"],
  "mappings": "aACA,OAAQ,0BAAAA,MAA6B,6BACrC,OAAQ,qBAAAC,EAAmB,eAAAC,MAAkB,wBAC7C,OAAQ,uBAAAC,EAAqB,eAAAC,MAAkB,sBAO/C,MAAMC,EAAyB,CAC7B,IAAI,CAAC,KAAAC,CAAI,EAAG,CACV,GAAI,CAACN,EAAuBM,CAAI,GAAKA,EAAK,KAAK,OAAS,EACtD,OAEF,MAAMC,EAAcD,EAAK,KAAK,CAAC,EAAE,KAC3BE,EAAc,CAAC,EACrB,IAAIC,EAAqB,GACrBC,EAAI,EACR,KAAO,CAACD,GAAoB,CAC1B,MAAME,EAAWJ,EAAY,OAAS,EAAIG,EAC1CF,EAAY,KAAKD,EAAYI,CAAQ,CAAC,EACtC,UAAWC,KAAON,EAAK,KAAM,CAC3B,MAAMO,EAAgBD,EAAI,KAAK,OAAS,EAAIF,EACtCI,EAAMF,EAAI,KAAKC,CAAa,EAClC,GAAI,CAACC,GAAO,CAACX,EAAoBW,EAAI,IAAI,GAAK,CAACV,EAAYU,EAAKN,EAAYE,CAAC,CAAC,EAAG,CAC/ED,EAAqB,GACrB,KACF,CACF,CACAC,GACF,CAEA,GADAF,EAAY,IAAI,EAEd,CAACA,EAAY,QAGXA,EAAY,SAAW,GAGvBA,EAAY,CAAC,EAAE,OAAS,aAExBF,EAAK,KAAK,OAAS,GAGnBA,EAAK,KAAK,MAAMM,GAAOA,EAAI,KAAK,OAAS,CAAC,EAG5C,OAEFJ,EAAY,QAAQ,EAEpB,UAAWI,KAAON,EAAK,KACrBM,EAAI,KAAOA,EAAI,KAAK,MAAM,EAAG,CAACJ,EAAY,MAAM,EAElD,MAAMO,EAAiBd,EAAkB,EACnCe,EAAcd,EAAY,CAAC,KAAMI,EAAK,IAAI,CAAC,EAC5CU,EAAY,KAAK,MAAMJ,GAAO,CAACA,EAAI,KAAK,MAAM,GACjDG,EAAe,KAAK,KAAKC,CAAW,EAEtCD,EAAe,KAAK,KAAK,GAAGP,CAAW,EACvCF,EAAK,KAAO,CAACS,CAAc,CAC7B,CACF,EAEA,OACEV,KAAA",
  "names": ["isAlternativeContainer", "createAlternative", "createGroup", "isAllowedSimpleType", "isNodeEqual", "extractSuffix", "node", "firstAltEls", "suffixNodes", "passedSharedSuffix", "i", "inverseI", "alt", "inverseIOfAlt", "kid", "newContentsAlt", "prefixGroup"]
}
